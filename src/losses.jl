"""
    ClimaGen.score_matching_loss

# Notes
Denoising score matching objective:
```julia
min wrt. Î¸ (
    ğ”¼ wrt. ğ˜µ âˆ¼ ğ’°(0, ğ˜›)[
        Î»(ğ˜µ) * ğ”¼ wrt. ğ˜¹(0) âˆ¼ ğ’«â‚€(ğ˜¹) [
            ğ”¼ wrt. ğ˜¹(t) âˆ¼ ğ’«â‚€â‚œ(ğ˜¹(ğ˜µ)|ğ˜¹(0)) [
                (||sâ‚€(ğ˜¹(ğ˜µ), ğ˜µ) - âˆ‡ log [ğ’«â‚€â‚œ(ğ˜¹(ğ˜µ) | ğ˜¹(0))] ||â‚‚)Â²
            ]
        ]
    ]
)
``` 
Where ğ’«â‚€â‚œ(ğ˜¹(ğ˜µ) | ğ˜¹(0)) and Î»(ğ˜µ), are available analytically and
sâ‚€(ğ˜¹(ğ˜µ), ğ˜µ) is estimated by a U-Net architecture.

# References:
https://arxiv.org/abs/2011.13456
https://arxiv.org/abs/1907.05600
"""
function score_matching_loss(model::AbstractDiffusionModel, x_0, Ïµ=5.0f-5)
    # sample times
    t = rand!(similar(x_0, size(x_0)[end])) .* (1 - Ïµ) .+ Ïµ

    # sample from normal marginal
    z = randn!(similar(x_0))
    Î¼_t, Ïƒ_t = marginal_prob(model, x_0, t)
    x_t = @. Î¼_t + Ïƒ_t * z

    # evaluate model score sâ‚€(ğ˜¹(ğ˜µ), ğ˜µ)
    s_t = score(model, x_t, t)

    # Assume that Î»(t) = Ïƒ(t)Â² and pull it into Lâ‚‚-norm
    # Below, z / Ïƒ_t = -âˆ‡ log [ğ’«â‚€â‚œ(ğ˜¹(ğ˜µ) | ğ˜¹(0))
    loss = @. (z + Ïƒ_t * s_t)^2 # squared deviations from real score
    loss = sum(loss, dims=1:(ndims(x_0)-1)) # Lâ‚‚-norm
    loss = Statistics.mean(loss) # mean over samples/batches

    return loss
end
